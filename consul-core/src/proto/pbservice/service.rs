// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.15.8
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/pbservice/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct ConnectProxyConfig {
    // message fields
    pub DestinationServiceName: ::std::string::String,
    pub DestinationServiceID: ::std::string::String,
    pub LocalServiceAddress: ::std::string::String,
    pub LocalServicePort: i32,
    pub Config: ::protobuf::MessageField<::protobuf::well_known_types::Struct>,
    pub Upstreams: ::std::vec::Vec<Upstream>,
    pub MeshGateway: ::protobuf::MessageField<MeshGatewayConfig>,
    pub Expose: ::protobuf::MessageField<ExposeConfig>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectProxyConfig {
    fn default() -> &'a ConnectProxyConfig {
        <ConnectProxyConfig as ::protobuf::Message>::default_instance()
    }
}

impl ConnectProxyConfig {
    pub fn new() -> ConnectProxyConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DestinationServiceName",
            |m: &ConnectProxyConfig| { &m.DestinationServiceName },
            |m: &mut ConnectProxyConfig| { &mut m.DestinationServiceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DestinationServiceID",
            |m: &ConnectProxyConfig| { &m.DestinationServiceID },
            |m: &mut ConnectProxyConfig| { &mut m.DestinationServiceID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LocalServiceAddress",
            |m: &ConnectProxyConfig| { &m.LocalServiceAddress },
            |m: &mut ConnectProxyConfig| { &mut m.LocalServiceAddress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LocalServicePort",
            |m: &ConnectProxyConfig| { &m.LocalServicePort },
            |m: &mut ConnectProxyConfig| { &mut m.LocalServicePort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Struct>(
            "Config",
            |m: &ConnectProxyConfig| { &m.Config },
            |m: &mut ConnectProxyConfig| { &mut m.Config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Upstreams",
            |m: &ConnectProxyConfig| { &m.Upstreams },
            |m: &mut ConnectProxyConfig| { &mut m.Upstreams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MeshGatewayConfig>(
            "MeshGateway",
            |m: &ConnectProxyConfig| { &m.MeshGateway },
            |m: &mut ConnectProxyConfig| { &mut m.MeshGateway },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExposeConfig>(
            "Expose",
            |m: &ConnectProxyConfig| { &m.Expose },
            |m: &mut ConnectProxyConfig| { &mut m.Expose },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectProxyConfig>(
            "ConnectProxyConfig",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for ConnectProxyConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.Config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Upstreams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.MeshGateway {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Expose {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DestinationServiceName = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DestinationServiceID = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.LocalServiceAddress = is.read_string()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.LocalServicePort = is.read_int32()?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Config)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.Upstreams)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.MeshGateway)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Expose)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.DestinationServiceName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.DestinationServiceName);
        }
        if !self.DestinationServiceID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.DestinationServiceID);
        }
        if !self.LocalServiceAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.LocalServiceAddress);
        }
        if self.LocalServicePort != 0 {
            my_size += ::protobuf::rt::value_size(4, self.LocalServicePort, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Upstreams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.MeshGateway.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.Expose.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.DestinationServiceName.is_empty() {
            os.write_string(1, &self.DestinationServiceName)?;
        }
        if !self.DestinationServiceID.is_empty() {
            os.write_string(2, &self.DestinationServiceID)?;
        }
        if !self.LocalServiceAddress.is_empty() {
            os.write_string(3, &self.LocalServiceAddress)?;
        }
        if self.LocalServicePort != 0 {
            os.write_int32(4, self.LocalServicePort)?;
        }
        if let Some(v) = self.Config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.Upstreams {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.MeshGateway.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.Expose.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ConnectProxyConfig {
        ConnectProxyConfig::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static ConnectProxyConfig {
        static instance: ConnectProxyConfig = ConnectProxyConfig {
            DestinationServiceName: ::std::string::String::new(),
            DestinationServiceID: ::std::string::String::new(),
            LocalServiceAddress: ::std::string::String::new(),
            LocalServicePort: 0,
            Config: ::protobuf::MessageField::none(),
            Upstreams: ::std::vec::Vec::new(),
            MeshGateway: ::protobuf::MessageField::none(),
            Expose: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ConnectProxyConfig {
    fn clear(&mut self) {
        self.DestinationServiceName.clear();
        self.DestinationServiceID.clear();
        self.LocalServiceAddress.clear();
        self.LocalServicePort = 0;
        self.Config.clear();
        self.Upstreams.clear();
        self.MeshGateway.clear();
        self.Expose.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectProxyConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectProxyConfig {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct Upstream {
    // message fields
    pub DestinationType: ::std::string::String,
    pub DestinationNamespace: ::std::string::String,
    pub DestinationName: ::std::string::String,
    pub Datacenter: ::std::string::String,
    pub LocalBindAddress: ::std::string::String,
    pub LocalBindPort: i32,
    pub Config: ::protobuf::MessageField<::protobuf::well_known_types::Struct>,
    pub MeshGateway: ::protobuf::MessageField<MeshGatewayConfig>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Upstream {
    fn default() -> &'a Upstream {
        <Upstream as ::protobuf::Message>::default_instance()
    }
}

impl Upstream {
    pub fn new() -> Upstream {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DestinationType",
            |m: &Upstream| { &m.DestinationType },
            |m: &mut Upstream| { &mut m.DestinationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DestinationNamespace",
            |m: &Upstream| { &m.DestinationNamespace },
            |m: &mut Upstream| { &mut m.DestinationNamespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DestinationName",
            |m: &Upstream| { &m.DestinationName },
            |m: &mut Upstream| { &mut m.DestinationName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Datacenter",
            |m: &Upstream| { &m.Datacenter },
            |m: &mut Upstream| { &mut m.Datacenter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LocalBindAddress",
            |m: &Upstream| { &m.LocalBindAddress },
            |m: &mut Upstream| { &mut m.LocalBindAddress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LocalBindPort",
            |m: &Upstream| { &m.LocalBindPort },
            |m: &mut Upstream| { &mut m.LocalBindPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Struct>(
            "Config",
            |m: &Upstream| { &m.Config },
            |m: &mut Upstream| { &mut m.Config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MeshGatewayConfig>(
            "MeshGateway",
            |m: &Upstream| { &m.MeshGateway },
            |m: &mut Upstream| { &mut m.MeshGateway },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Upstream>(
            "Upstream",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for Upstream {
    fn is_initialized(&self) -> bool {
        for v in &self.Config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.MeshGateway {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DestinationType = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DestinationNamespace = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DestinationName = is.read_string()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Datacenter = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.LocalBindAddress = is.read_string()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.LocalBindPort = is.read_int32()?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Config)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.MeshGateway)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.DestinationType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.DestinationType);
        }
        if !self.DestinationNamespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.DestinationNamespace);
        }
        if !self.DestinationName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.DestinationName);
        }
        if !self.Datacenter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Datacenter);
        }
        if !self.LocalBindAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.LocalBindAddress);
        }
        if self.LocalBindPort != 0 {
            my_size += ::protobuf::rt::value_size(6, self.LocalBindPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.MeshGateway.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.DestinationType.is_empty() {
            os.write_string(1, &self.DestinationType)?;
        }
        if !self.DestinationNamespace.is_empty() {
            os.write_string(2, &self.DestinationNamespace)?;
        }
        if !self.DestinationName.is_empty() {
            os.write_string(3, &self.DestinationName)?;
        }
        if !self.Datacenter.is_empty() {
            os.write_string(4, &self.Datacenter)?;
        }
        if !self.LocalBindAddress.is_empty() {
            os.write_string(5, &self.LocalBindAddress)?;
        }
        if self.LocalBindPort != 0 {
            os.write_int32(6, self.LocalBindPort)?;
        }
        if let Some(v) = self.Config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.MeshGateway.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Upstream {
        Upstream::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static Upstream {
        static instance: Upstream = Upstream {
            DestinationType: ::std::string::String::new(),
            DestinationNamespace: ::std::string::String::new(),
            DestinationName: ::std::string::String::new(),
            Datacenter: ::std::string::String::new(),
            LocalBindAddress: ::std::string::String::new(),
            LocalBindPort: 0,
            Config: ::protobuf::MessageField::none(),
            MeshGateway: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Upstream {
    fn clear(&mut self) {
        self.DestinationType.clear();
        self.DestinationNamespace.clear();
        self.DestinationName.clear();
        self.Datacenter.clear();
        self.LocalBindAddress.clear();
        self.LocalBindPort = 0;
        self.Config.clear();
        self.MeshGateway.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Upstream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Upstream {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct ServiceConnect {
    // message fields
    pub Native: bool,
    pub SidecarService: ::protobuf::MessageField<ServiceDefinition>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceConnect {
    fn default() -> &'a ServiceConnect {
        <ServiceConnect as ::protobuf::Message>::default_instance()
    }
}

impl ServiceConnect {
    pub fn new() -> ServiceConnect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Native",
            |m: &ServiceConnect| { &m.Native },
            |m: &mut ServiceConnect| { &mut m.Native },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceDefinition>(
            "SidecarService",
            |m: &ServiceConnect| { &m.SidecarService },
            |m: &mut ServiceConnect| { &mut m.SidecarService },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceConnect>(
            "ServiceConnect",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for ServiceConnect {
    fn is_initialized(&self) -> bool {
        for v in &self.SidecarService {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Native = is.read_bool()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.SidecarService)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Native != false {
            my_size += 2;
        }
        if let Some(v) = self.SidecarService.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Native != false {
            os.write_bool(1, self.Native)?;
        }
        if let Some(v) = self.SidecarService.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ServiceConnect {
        ServiceConnect::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static ServiceConnect {
        static instance: ServiceConnect = ServiceConnect {
            Native: false,
            SidecarService: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ServiceConnect {
    fn clear(&mut self) {
        self.Native = false;
        self.SidecarService.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceConnect {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct ExposeConfig {
    // message fields
    pub Checks: bool,
    pub Paths: ::std::vec::Vec<ExposePath>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExposeConfig {
    fn default() -> &'a ExposeConfig {
        <ExposeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ExposeConfig {
    pub fn new() -> ExposeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Checks",
            |m: &ExposeConfig| { &m.Checks },
            |m: &mut ExposeConfig| { &mut m.Checks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Paths",
            |m: &ExposeConfig| { &m.Paths },
            |m: &mut ExposeConfig| { &mut m.Paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExposeConfig>(
            "ExposeConfig",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for ExposeConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.Paths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Checks = is.read_bool()?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.Paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Checks != false {
            my_size += 2;
        }
        for value in &self.Paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Checks != false {
            os.write_bool(1, self.Checks)?;
        }
        for v in &self.Paths {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExposeConfig {
        ExposeConfig::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static ExposeConfig {
        static instance: ExposeConfig = ExposeConfig {
            Checks: false,
            Paths: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExposeConfig {
    fn clear(&mut self) {
        self.Checks = false;
        self.Paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExposeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExposeConfig {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct ExposePath {
    // message fields
    pub ListenerPort: i32,
    pub Path: ::std::string::String,
    pub LocalPathPort: i32,
    pub Protocol: ::std::string::String,
    pub ParsedFromCheck: bool,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExposePath {
    fn default() -> &'a ExposePath {
        <ExposePath as ::protobuf::Message>::default_instance()
    }
}

impl ExposePath {
    pub fn new() -> ExposePath {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ListenerPort",
            |m: &ExposePath| { &m.ListenerPort },
            |m: &mut ExposePath| { &mut m.ListenerPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Path",
            |m: &ExposePath| { &m.Path },
            |m: &mut ExposePath| { &mut m.Path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LocalPathPort",
            |m: &ExposePath| { &m.LocalPathPort },
            |m: &mut ExposePath| { &mut m.LocalPathPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Protocol",
            |m: &ExposePath| { &m.Protocol },
            |m: &mut ExposePath| { &mut m.Protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ParsedFromCheck",
            |m: &ExposePath| { &m.ParsedFromCheck },
            |m: &mut ExposePath| { &mut m.ParsedFromCheck },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExposePath>(
            "ExposePath",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for ExposePath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ListenerPort = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Path = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.LocalPathPort = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Protocol = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ParsedFromCheck = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ListenerPort != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ListenerPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Path);
        }
        if self.LocalPathPort != 0 {
            my_size += ::protobuf::rt::value_size(3, self.LocalPathPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Protocol);
        }
        if self.ParsedFromCheck != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ListenerPort != 0 {
            os.write_int32(1, self.ListenerPort)?;
        }
        if !self.Path.is_empty() {
            os.write_string(2, &self.Path)?;
        }
        if self.LocalPathPort != 0 {
            os.write_int32(3, self.LocalPathPort)?;
        }
        if !self.Protocol.is_empty() {
            os.write_string(4, &self.Protocol)?;
        }
        if self.ParsedFromCheck != false {
            os.write_bool(5, self.ParsedFromCheck)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExposePath {
        ExposePath::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static ExposePath {
        static instance: ExposePath = ExposePath {
            ListenerPort: 0,
            Path: ::std::string::String::new(),
            LocalPathPort: 0,
            Protocol: ::std::string::String::new(),
            ParsedFromCheck: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExposePath {
    fn clear(&mut self) {
        self.ListenerPort = 0;
        self.Path.clear();
        self.LocalPathPort = 0;
        self.Protocol.clear();
        self.ParsedFromCheck = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExposePath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExposePath {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct MeshGatewayConfig {
    // message fields
    pub Mode: ::std::string::String,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeshGatewayConfig {
    fn default() -> &'a MeshGatewayConfig {
        <MeshGatewayConfig as ::protobuf::Message>::default_instance()
    }
}

impl MeshGatewayConfig {
    pub fn new() -> MeshGatewayConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Mode",
            |m: &MeshGatewayConfig| { &m.Mode },
            |m: &mut MeshGatewayConfig| { &mut m.Mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MeshGatewayConfig>(
            "MeshGatewayConfig",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for MeshGatewayConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Mode = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Mode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Mode.is_empty() {
            os.write_string(1, &self.Mode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MeshGatewayConfig {
        MeshGatewayConfig::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static MeshGatewayConfig {
        static instance: MeshGatewayConfig = MeshGatewayConfig {
            Mode: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MeshGatewayConfig {
    fn clear(&mut self) {
        self.Mode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeshGatewayConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeshGatewayConfig {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct ServiceDefinition {
    // message fields
    pub Kind: ::std::string::String,
    pub ID: ::std::string::String,
    pub Name: ::std::string::String,
    pub Tags: ::std::vec::Vec<::std::string::String>,
    pub Address: ::std::string::String,
    #[serde(default)]
    pub TaggedAddresses: ::std::collections::HashMap<::std::string::String, ServiceAddress>,
    #[serde(default)]
    pub Meta: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub Port: i32,
    pub Check: ::protobuf::MessageField<super::healthcheck::CheckType>,
    pub Checks: ::std::vec::Vec<super::healthcheck::CheckType>,
    pub Weights: ::protobuf::MessageField<Weights>,
    pub Token: ::std::string::String,
    pub EnableTagOverride: bool,
    pub Proxy: ::protobuf::MessageField<ConnectProxyConfig>,
    pub EnterpriseMeta: ::protobuf::MessageField<super::common::EnterpriseMeta>,
    pub Connect: ::protobuf::MessageField<ServiceConnect>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceDefinition {
    fn default() -> &'a ServiceDefinition {
        <ServiceDefinition as ::protobuf::Message>::default_instance()
    }
}

impl ServiceDefinition {
    pub fn new() -> ServiceDefinition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Kind",
            |m: &ServiceDefinition| { &m.Kind },
            |m: &mut ServiceDefinition| { &mut m.Kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ID",
            |m: &ServiceDefinition| { &m.ID },
            |m: &mut ServiceDefinition| { &mut m.ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Name",
            |m: &ServiceDefinition| { &m.Name },
            |m: &mut ServiceDefinition| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Tags",
            |m: &ServiceDefinition| { &m.Tags },
            |m: &mut ServiceDefinition| { &mut m.Tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Address",
            |m: &ServiceDefinition| { &m.Address },
            |m: &mut ServiceDefinition| { &mut m.Address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "TaggedAddresses",
            |m: &ServiceDefinition| { &m.TaggedAddresses },
            |m: &mut ServiceDefinition| { &mut m.TaggedAddresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "Meta",
            |m: &ServiceDefinition| { &m.Meta },
            |m: &mut ServiceDefinition| { &mut m.Meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Port",
            |m: &ServiceDefinition| { &m.Port },
            |m: &mut ServiceDefinition| { &mut m.Port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::healthcheck::CheckType>(
            "Check",
            |m: &ServiceDefinition| { &m.Check },
            |m: &mut ServiceDefinition| { &mut m.Check },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Checks",
            |m: &ServiceDefinition| { &m.Checks },
            |m: &mut ServiceDefinition| { &mut m.Checks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Weights>(
            "Weights",
            |m: &ServiceDefinition| { &m.Weights },
            |m: &mut ServiceDefinition| { &mut m.Weights },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Token",
            |m: &ServiceDefinition| { &m.Token },
            |m: &mut ServiceDefinition| { &mut m.Token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EnableTagOverride",
            |m: &ServiceDefinition| { &m.EnableTagOverride },
            |m: &mut ServiceDefinition| { &mut m.EnableTagOverride },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectProxyConfig>(
            "Proxy",
            |m: &ServiceDefinition| { &m.Proxy },
            |m: &mut ServiceDefinition| { &mut m.Proxy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::EnterpriseMeta>(
            "EnterpriseMeta",
            |m: &ServiceDefinition| { &m.EnterpriseMeta },
            |m: &mut ServiceDefinition| { &mut m.EnterpriseMeta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceConnect>(
            "Connect",
            |m: &ServiceDefinition| { &m.Connect },
            |m: &mut ServiceDefinition| { &mut m.Connect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDefinition>(
            "ServiceDefinition",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for ServiceDefinition {
    fn is_initialized(&self) -> bool {
        for v in &self.Check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Checks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Weights {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Proxy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EnterpriseMeta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Connect {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Kind = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ID = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Name = is.read_string()?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Address = is.read_string()?;
                },
                16 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<ServiceAddress>>(wire_type, is, &mut self.TaggedAddresses)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeString>(wire_type, is, &mut self.Meta)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Port = is.read_int32()?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Check)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.Checks)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Weights)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Token = is.read_string()?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.EnableTagOverride = is.read_bool()?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Proxy)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.EnterpriseMeta)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Connect)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Kind.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Kind);
        }
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ID);
        }
        if !self.Name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Name);
        }
        for value in &self.Tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.Address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Address);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<ServiceAddress>>(16, &self.TaggedAddresses);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeString>(6, &self.Meta);
        if self.Port != 0 {
            my_size += ::protobuf::rt::value_size(7, self.Port, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Checks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.Weights.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Token.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.Token);
        }
        if self.EnableTagOverride != false {
            my_size += 2;
        }
        if let Some(v) = self.Proxy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.EnterpriseMeta.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.Connect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Kind.is_empty() {
            os.write_string(1, &self.Kind)?;
        }
        if !self.ID.is_empty() {
            os.write_string(2, &self.ID)?;
        }
        if !self.Name.is_empty() {
            os.write_string(3, &self.Name)?;
        }
        for v in &self.Tags {
            os.write_string(4, &v)?;
        };
        if !self.Address.is_empty() {
            os.write_string(5, &self.Address)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<ServiceAddress>>(16, &self.TaggedAddresses, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeString>(6, &self.Meta, os)?;
        if self.Port != 0 {
            os.write_int32(7, self.Port)?;
        }
        if let Some(v) = self.Check.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.Checks {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.Weights.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if !self.Token.is_empty() {
            os.write_string(11, &self.Token)?;
        }
        if self.EnableTagOverride != false {
            os.write_bool(12, self.EnableTagOverride)?;
        }
        if let Some(v) = self.Proxy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.EnterpriseMeta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.Connect.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ServiceDefinition {
        ServiceDefinition::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static ServiceDefinition {
        static instance: ::protobuf::rt::LazyV2<ServiceDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceDefinition::new)
    }
}

impl ::protobuf::Clear for ServiceDefinition {
    fn clear(&mut self) {
        self.Kind.clear();
        self.ID.clear();
        self.Name.clear();
        self.Tags.clear();
        self.Address.clear();
        self.TaggedAddresses.clear();
        self.Meta.clear();
        self.Port = 0;
        self.Check.clear();
        self.Checks.clear();
        self.Weights.clear();
        self.Token.clear();
        self.EnableTagOverride = false;
        self.Proxy.clear();
        self.EnterpriseMeta.clear();
        self.Connect.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceDefinition {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct ServiceAddress {
    // message fields
    pub Address: ::std::string::String,
    pub Port: i32,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceAddress {
    fn default() -> &'a ServiceAddress {
        <ServiceAddress as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAddress {
    pub fn new() -> ServiceAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Address",
            |m: &ServiceAddress| { &m.Address },
            |m: &mut ServiceAddress| { &mut m.Address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Port",
            |m: &ServiceAddress| { &m.Port },
            |m: &mut ServiceAddress| { &mut m.Port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceAddress>(
            "ServiceAddress",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for ServiceAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Address = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Port = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Address);
        }
        if self.Port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Address.is_empty() {
            os.write_string(1, &self.Address)?;
        }
        if self.Port != 0 {
            os.write_int32(2, self.Port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ServiceAddress {
        ServiceAddress::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static ServiceAddress {
        static instance: ServiceAddress = ServiceAddress {
            Address: ::std::string::String::new(),
            Port: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ServiceAddress {
    fn clear(&mut self) {
        self.Address.clear();
        self.Port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAddress {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct Weights {
    // message fields
    pub Passing: i32,
    pub Warning: i32,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Weights {
    fn default() -> &'a Weights {
        <Weights as ::protobuf::Message>::default_instance()
    }
}

impl Weights {
    pub fn new() -> Weights {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Passing",
            |m: &Weights| { &m.Passing },
            |m: &mut Weights| { &mut m.Passing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Warning",
            |m: &Weights| { &m.Warning },
            |m: &mut Weights| { &mut m.Warning },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Weights>(
            "Weights",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for Weights {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Passing = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Warning = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Passing != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Passing, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Warning != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Warning, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Passing != 0 {
            os.write_int32(1, self.Passing)?;
        }
        if self.Warning != 0 {
            os.write_int32(2, self.Warning)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Weights {
        Weights::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static Weights {
        static instance: Weights = Weights {
            Passing: 0,
            Warning: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Weights {
    fn clear(&mut self) {
        self.Passing = 0;
        self.Warning = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Weights {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Weights {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dproto/pbservice/service.proto\x12\tpbservice\x1a\x1cgoogle/protobu\
    f/struct.proto\x1a\x1bproto/pbcommon/common.proto\x1a!proto/pbservice/he\
    althcheck.proto\x1a\x14gogoproto/gogo.proto\"\xcb\x03\n\x12ConnectProxyC\
    onfig\x126\n\x16DestinationServiceName\x18\x01\x20\x01(\tR\x16Destinatio\
    nServiceName\x122\n\x14DestinationServiceID\x18\x02\x20\x01(\tR\x14Desti\
    nationServiceID\x120\n\x13LocalServiceAddress\x18\x03\x20\x01(\tR\x13Loc\
    alServiceAddress\x12*\n\x10LocalServicePort\x18\x04\x20\x01(\x05R\x10Loc\
    alServicePort\x125\n\x06Config\x18\x05\x20\x01(\x0b2\x17.google.protobuf\
    .StructR\x06ConfigB\x04\xc8\xde\x1f\x01\x127\n\tUpstreams\x18\x06\x20\
    \x03(\x0b2\x13.pbservice.UpstreamR\tUpstreamsB\x04\xc8\xde\x1f\0\x12D\n\
    \x0bMeshGateway\x18\x07\x20\x01(\x0b2\x1c.pbservice.MeshGatewayConfigR\
    \x0bMeshGatewayB\x04\xc8\xde\x1f\0\x125\n\x06Expose\x18\x08\x20\x01(\x0b\
    2\x17.pbservice.ExposeConfigR\x06ExposeB\x04\xc8\xde\x1f\0\"\x81\x03\n\
    \x08Upstream\x12(\n\x0fDestinationType\x18\x01\x20\x01(\tR\x0fDestinatio\
    nType\x122\n\x14DestinationNamespace\x18\x02\x20\x01(\tR\x14DestinationN\
    amespace\x12(\n\x0fDestinationName\x18\x03\x20\x01(\tR\x0fDestinationNam\
    e\x12\x1e\n\nDatacenter\x18\x04\x20\x01(\tR\nDatacenter\x12*\n\x10LocalB\
    indAddress\x18\x05\x20\x01(\tR\x10LocalBindAddress\x12$\n\rLocalBindPort\
    \x18\x06\x20\x01(\x05R\rLocalBindPort\x125\n\x06Config\x18\x07\x20\x01(\
    \x0b2\x17.google.protobuf.StructR\x06ConfigB\x04\xc8\xde\x1f\x01\x12D\n\
    \x0bMeshGateway\x18\x08\x20\x01(\x0b2\x1c.pbservice.MeshGatewayConfigR\
    \x0bMeshGatewayB\x04\xc8\xde\x1f\0\"n\n\x0eServiceConnect\x12\x16\n\x06N\
    ative\x18\x01\x20\x01(\x08R\x06Native\x12D\n\x0eSidecarService\x18\x03\
    \x20\x01(\x0b2\x1c.pbservice.ServiceDefinitionR\x0eSidecarService\"Y\n\
    \x0cExposeConfig\x12\x16\n\x06Checks\x18\x01\x20\x01(\x08R\x06Checks\x12\
    1\n\x05Paths\x18\x02\x20\x03(\x0b2\x15.pbservice.ExposePathR\x05PathsB\
    \x04\xc8\xde\x1f\0\"\xb0\x01\n\nExposePath\x12\"\n\x0cListenerPort\x18\
    \x01\x20\x01(\x05R\x0cListenerPort\x12\x12\n\x04Path\x18\x02\x20\x01(\tR\
    \x04Path\x12$\n\rLocalPathPort\x18\x03\x20\x01(\x05R\rLocalPathPort\x12\
    \x1a\n\x08Protocol\x18\x04\x20\x01(\tR\x08Protocol\x12(\n\x0fParsedFromC\
    heck\x18\x05\x20\x01(\x08R\x0fParsedFromCheck\"f\n\x11MeshGatewayConfig\
    \x12Q\n\x04Mode\x18\x01\x20\x01(\tR\x04ModeB=\xfa\xde\x1f9github.com/has\
    hicorp/consul/agent/structs.MeshGatewayMode\"\x81\x07\n\x11ServiceDefini\
    tion\x12M\n\x04Kind\x18\x01\x20\x01(\tR\x04KindB9\xfa\xde\x1f5github.com\
    /hashicorp/consul/agent/structs.ServiceKind\x12\x0e\n\x02ID\x18\x02\x20\
    \x01(\tR\x02ID\x12\x12\n\x04Name\x18\x03\x20\x01(\tR\x04Name\x12\x12\n\
    \x04Tags\x18\x04\x20\x03(\tR\x04Tags\x12\x18\n\x07Address\x18\x05\x20\
    \x01(\tR\x07Address\x12a\n\x0fTaggedAddresses\x18\x10\x20\x03(\x0b21.pbs\
    ervice.ServiceDefinition.TaggedAddressesEntryR\x0fTaggedAddressesB\x04\
    \xc8\xde\x1f\0\x12:\n\x04Meta\x18\x06\x20\x03(\x0b2&.pbservice.ServiceDe\
    finition.MetaEntryR\x04Meta\x12\x12\n\x04Port\x18\x07\x20\x01(\x05R\x04P\
    ort\x120\n\x05Check\x18\x08\x20\x01(\x0b2\x14.pbservice.CheckTypeR\x05Ch\
    eckB\x04\xc8\xde\x1f\0\x12,\n\x06Checks\x18\t\x20\x03(\x0b2\x14.pbservic\
    e.CheckTypeR\x06Checks\x12,\n\x07Weights\x18\n\x20\x01(\x0b2\x12.pbservi\
    ce.WeightsR\x07Weights\x12\x14\n\x05Token\x18\x0b\x20\x01(\tR\x05Token\
    \x12,\n\x11EnableTagOverride\x18\x0c\x20\x01(\x08R\x11EnableTagOverride\
    \x123\n\x05Proxy\x18\x0e\x20\x01(\x0b2\x1d.pbservice.ConnectProxyConfigR\
    \x05Proxy\x12D\n\x0eEnterpriseMeta\x18\x11\x20\x01(\x0b2\x16.common.Ente\
    rpriseMetaR\x0eEnterpriseMetaB\x04\xc8\xde\x1f\0\x123\n\x07Connect\x18\
    \x0f\x20\x01(\x0b2\x19.pbservice.ServiceConnectR\x07Connect\x1a]\n\x14Ta\
    ggedAddressesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12/\n\
    \x05value\x18\x02\x20\x01(\x0b2\x19.pbservice.ServiceAddressR\x05value:\
    \x028\x01\x1a7\n\tMetaEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\">\n\x0eServi\
    ceAddress\x12\x18\n\x07Address\x18\x01\x20\x01(\tR\x07Address\x12\x12\n\
    \x04Port\x18\x02\x20\x01(\x05R\x04Port\"=\n\x07Weights\x12\x18\n\x07Pass\
    ing\x18\x01\x20\x01(\x05R\x07Passing\x12\x18\n\x07Warning\x18\x02\x20\
    \x01(\x05R\x07WarningB=Z+github.com/hashicorp/consul/proto/pbservice\xd0\
    \xe3\x1e\0\xd8\xe3\x1e\0\x90\xe3\x1e\0\xc8\xe1\x1e\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(::protobuf::well_known_types::file_descriptors::struct_pb());
        deps.push(super::common::file_descriptor());
        deps.push(super::healthcheck::file_descriptor());
        deps.push(super::gogo::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(ConnectProxyConfig::generated_message_descriptor_data());
        messages.push(Upstream::generated_message_descriptor_data());
        messages.push(ServiceConnect::generated_message_descriptor_data());
        messages.push(ExposeConfig::generated_message_descriptor_data());
        messages.push(ExposePath::generated_message_descriptor_data());
        messages.push(MeshGatewayConfig::generated_message_descriptor_data());
        messages.push(ServiceDefinition::generated_message_descriptor_data());
        messages.push(ServiceAddress::generated_message_descriptor_data());
        messages.push(Weights::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
