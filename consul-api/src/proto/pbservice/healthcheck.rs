// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.15.8
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/pbservice/healthcheck.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct HealthCheck {
    // message fields
    pub Node: ::std::string::String,
    pub CheckID: ::std::string::String,
    pub Name: ::std::string::String,
    pub Status: ::std::string::String,
    pub Notes: ::std::string::String,
    pub Output: ::std::string::String,
    pub ServiceID: ::std::string::String,
    pub ServiceName: ::std::string::String,
    pub ServiceTags: ::std::vec::Vec<::std::string::String>,
    pub Type: ::std::string::String,
    pub Definition: ::protobuf::MessageField<HealthCheckDefinition>,
    pub RaftIndex: ::protobuf::MessageField<super::common::RaftIndex>,
    pub EnterpriseMeta: ::protobuf::MessageField<super::common::EnterpriseMeta>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck {
    fn default() -> &'a HealthCheck {
        <HealthCheck as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheck {
    pub fn new() -> HealthCheck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Node",
            |m: &HealthCheck| { &m.Node },
            |m: &mut HealthCheck| { &mut m.Node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CheckID",
            |m: &HealthCheck| { &m.CheckID },
            |m: &mut HealthCheck| { &mut m.CheckID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Name",
            |m: &HealthCheck| { &m.Name },
            |m: &mut HealthCheck| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Status",
            |m: &HealthCheck| { &m.Status },
            |m: &mut HealthCheck| { &mut m.Status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Notes",
            |m: &HealthCheck| { &m.Notes },
            |m: &mut HealthCheck| { &mut m.Notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Output",
            |m: &HealthCheck| { &m.Output },
            |m: &mut HealthCheck| { &mut m.Output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ServiceID",
            |m: &HealthCheck| { &m.ServiceID },
            |m: &mut HealthCheck| { &mut m.ServiceID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ServiceName",
            |m: &HealthCheck| { &m.ServiceName },
            |m: &mut HealthCheck| { &mut m.ServiceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ServiceTags",
            |m: &HealthCheck| { &m.ServiceTags },
            |m: &mut HealthCheck| { &mut m.ServiceTags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &HealthCheck| { &m.Type },
            |m: &mut HealthCheck| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HealthCheckDefinition>(
            "Definition",
            |m: &HealthCheck| { &m.Definition },
            |m: &mut HealthCheck| { &mut m.Definition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RaftIndex>(
            "RaftIndex",
            |m: &HealthCheck| { &m.RaftIndex },
            |m: &mut HealthCheck| { &mut m.RaftIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::EnterpriseMeta>(
            "EnterpriseMeta",
            |m: &HealthCheck| { &m.EnterpriseMeta },
            |m: &mut HealthCheck| { &mut m.EnterpriseMeta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HealthCheck>(
            "HealthCheck",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for HealthCheck {
    fn is_initialized(&self) -> bool {
        for v in &self.Definition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.RaftIndex {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EnterpriseMeta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Node = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.CheckID = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Name = is.read_string()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Status = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Notes = is.read_string()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Output = is.read_string()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ServiceID = is.read_string()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ServiceName = is.read_string()?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ServiceTags)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = is.read_string()?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Definition)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.RaftIndex)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.EnterpriseMeta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Node.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Node);
        }
        if !self.CheckID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.CheckID);
        }
        if !self.Name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Name);
        }
        if !self.Status.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Status);
        }
        if !self.Notes.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Notes);
        }
        if !self.Output.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Output);
        }
        if !self.ServiceID.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.ServiceID);
        }
        if !self.ServiceName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.ServiceName);
        }
        for value in &self.ServiceTags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.Type);
        }
        if let Some(v) = self.Definition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.RaftIndex.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.EnterpriseMeta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Node.is_empty() {
            os.write_string(1, &self.Node)?;
        }
        if !self.CheckID.is_empty() {
            os.write_string(2, &self.CheckID)?;
        }
        if !self.Name.is_empty() {
            os.write_string(3, &self.Name)?;
        }
        if !self.Status.is_empty() {
            os.write_string(4, &self.Status)?;
        }
        if !self.Notes.is_empty() {
            os.write_string(5, &self.Notes)?;
        }
        if !self.Output.is_empty() {
            os.write_string(6, &self.Output)?;
        }
        if !self.ServiceID.is_empty() {
            os.write_string(7, &self.ServiceID)?;
        }
        if !self.ServiceName.is_empty() {
            os.write_string(8, &self.ServiceName)?;
        }
        for v in &self.ServiceTags {
            os.write_string(9, &v)?;
        };
        if !self.Type.is_empty() {
            os.write_string(12, &self.Type)?;
        }
        if let Some(v) = self.Definition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.RaftIndex.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.EnterpriseMeta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> HealthCheck {
        HealthCheck::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static HealthCheck {
        static instance: HealthCheck = HealthCheck {
            Node: ::std::string::String::new(),
            CheckID: ::std::string::String::new(),
            Name: ::std::string::String::new(),
            Status: ::std::string::String::new(),
            Notes: ::std::string::String::new(),
            Output: ::std::string::String::new(),
            ServiceID: ::std::string::String::new(),
            ServiceName: ::std::string::String::new(),
            ServiceTags: ::std::vec::Vec::new(),
            Type: ::std::string::String::new(),
            Definition: ::protobuf::MessageField::none(),
            RaftIndex: ::protobuf::MessageField::none(),
            EnterpriseMeta: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for HealthCheck {
    fn clear(&mut self) {
        self.Node.clear();
        self.CheckID.clear();
        self.Name.clear();
        self.Status.clear();
        self.Notes.clear();
        self.Output.clear();
        self.ServiceID.clear();
        self.ServiceName.clear();
        self.ServiceTags.clear();
        self.Type.clear();
        self.Definition.clear();
        self.RaftIndex.clear();
        self.EnterpriseMeta.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct HeaderValue {
    // message fields
    pub Value: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderValue {
    fn default() -> &'a HeaderValue {
        <HeaderValue as ::protobuf::Message>::default_instance()
    }
}

impl HeaderValue {
    pub fn new() -> HeaderValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Value",
            |m: &HeaderValue| { &m.Value },
            |m: &mut HeaderValue| { &mut m.Value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderValue>(
            "HeaderValue",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for HeaderValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Value {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Value {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> HeaderValue {
        HeaderValue::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static HeaderValue {
        static instance: HeaderValue = HeaderValue {
            Value: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for HeaderValue {
    fn clear(&mut self) {
        self.Value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderValue {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct HealthCheckDefinition {
    // message fields
    pub HTTP: ::std::string::String,
    pub TLSSkipVerify: bool,
    #[serde(default)]
    pub Header: ::std::collections::HashMap<::std::string::String, HeaderValue>,
    pub Method: ::std::string::String,
    pub Body: ::std::string::String,
    pub TCP: ::std::string::String,
    pub Interval: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub OutputMaxSize: u32,
    pub Timeout: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub DeregisterCriticalServiceAfter: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub ScriptArgs: ::std::vec::Vec<::std::string::String>,
    pub DockerContainerID: ::std::string::String,
    pub Shell: ::std::string::String,
    pub GRPC: ::std::string::String,
    pub GRPCUseTLS: bool,
    pub AliasNode: ::std::string::String,
    pub AliasService: ::std::string::String,
    pub TTL: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheckDefinition {
    fn default() -> &'a HealthCheckDefinition {
        <HealthCheckDefinition as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckDefinition {
    pub fn new() -> HealthCheckDefinition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HTTP",
            |m: &HealthCheckDefinition| { &m.HTTP },
            |m: &mut HealthCheckDefinition| { &mut m.HTTP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TLSSkipVerify",
            |m: &HealthCheckDefinition| { &m.TLSSkipVerify },
            |m: &mut HealthCheckDefinition| { &mut m.TLSSkipVerify },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "Header",
            |m: &HealthCheckDefinition| { &m.Header },
            |m: &mut HealthCheckDefinition| { &mut m.Header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Method",
            |m: &HealthCheckDefinition| { &m.Method },
            |m: &mut HealthCheckDefinition| { &mut m.Method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Body",
            |m: &HealthCheckDefinition| { &m.Body },
            |m: &mut HealthCheckDefinition| { &mut m.Body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TCP",
            |m: &HealthCheckDefinition| { &m.TCP },
            |m: &mut HealthCheckDefinition| { &mut m.TCP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "Interval",
            |m: &HealthCheckDefinition| { &m.Interval },
            |m: &mut HealthCheckDefinition| { &mut m.Interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OutputMaxSize",
            |m: &HealthCheckDefinition| { &m.OutputMaxSize },
            |m: &mut HealthCheckDefinition| { &mut m.OutputMaxSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "Timeout",
            |m: &HealthCheckDefinition| { &m.Timeout },
            |m: &mut HealthCheckDefinition| { &mut m.Timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "DeregisterCriticalServiceAfter",
            |m: &HealthCheckDefinition| { &m.DeregisterCriticalServiceAfter },
            |m: &mut HealthCheckDefinition| { &mut m.DeregisterCriticalServiceAfter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ScriptArgs",
            |m: &HealthCheckDefinition| { &m.ScriptArgs },
            |m: &mut HealthCheckDefinition| { &mut m.ScriptArgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DockerContainerID",
            |m: &HealthCheckDefinition| { &m.DockerContainerID },
            |m: &mut HealthCheckDefinition| { &mut m.DockerContainerID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Shell",
            |m: &HealthCheckDefinition| { &m.Shell },
            |m: &mut HealthCheckDefinition| { &mut m.Shell },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GRPC",
            |m: &HealthCheckDefinition| { &m.GRPC },
            |m: &mut HealthCheckDefinition| { &mut m.GRPC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GRPCUseTLS",
            |m: &HealthCheckDefinition| { &m.GRPCUseTLS },
            |m: &mut HealthCheckDefinition| { &mut m.GRPCUseTLS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AliasNode",
            |m: &HealthCheckDefinition| { &m.AliasNode },
            |m: &mut HealthCheckDefinition| { &mut m.AliasNode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AliasService",
            |m: &HealthCheckDefinition| { &m.AliasService },
            |m: &mut HealthCheckDefinition| { &mut m.AliasService },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "TTL",
            |m: &HealthCheckDefinition| { &m.TTL },
            |m: &mut HealthCheckDefinition| { &mut m.TTL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HealthCheckDefinition>(
            "HealthCheckDefinition",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for HealthCheckDefinition {
    fn is_initialized(&self) -> bool {
        for v in &self.Interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DeregisterCriticalServiceAfter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TTL {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.HTTP = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TLSSkipVerify = is.read_bool()?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<HeaderValue>>(wire_type, is, &mut self.Header)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Method = is.read_string()?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Body = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TCP = is.read_string()?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Interval)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.OutputMaxSize = is.read_uint32()?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Timeout)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.DeregisterCriticalServiceAfter)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ScriptArgs)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DockerContainerID = is.read_string()?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Shell = is.read_string()?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.GRPC = is.read_string()?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.GRPCUseTLS = is.read_bool()?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.AliasNode = is.read_string()?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.AliasService = is.read_string()?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.TTL)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.HTTP.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.HTTP);
        }
        if self.TLSSkipVerify != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<HeaderValue>>(3, &self.Header);
        if !self.Method.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Method);
        }
        if !self.Body.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.Body);
        }
        if !self.TCP.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.TCP);
        }
        if let Some(v) = self.Interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.OutputMaxSize != 0 {
            my_size += ::protobuf::rt::value_size(9, self.OutputMaxSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.DeregisterCriticalServiceAfter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ScriptArgs {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if !self.DockerContainerID.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.DockerContainerID);
        }
        if !self.Shell.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.Shell);
        }
        if !self.GRPC.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.GRPC);
        }
        if self.GRPCUseTLS != false {
            my_size += 2;
        }
        if !self.AliasNode.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.AliasNode);
        }
        if !self.AliasService.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.AliasService);
        }
        if let Some(v) = self.TTL.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.HTTP.is_empty() {
            os.write_string(1, &self.HTTP)?;
        }
        if self.TLSSkipVerify != false {
            os.write_bool(2, self.TLSSkipVerify)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<HeaderValue>>(3, &self.Header, os)?;
        if !self.Method.is_empty() {
            os.write_string(4, &self.Method)?;
        }
        if !self.Body.is_empty() {
            os.write_string(18, &self.Body)?;
        }
        if !self.TCP.is_empty() {
            os.write_string(5, &self.TCP)?;
        }
        if let Some(v) = self.Interval.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.OutputMaxSize != 0 {
            os.write_uint32(9, self.OutputMaxSize)?;
        }
        if let Some(v) = self.Timeout.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.DeregisterCriticalServiceAfter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.ScriptArgs {
            os.write_string(10, &v)?;
        };
        if !self.DockerContainerID.is_empty() {
            os.write_string(11, &self.DockerContainerID)?;
        }
        if !self.Shell.is_empty() {
            os.write_string(12, &self.Shell)?;
        }
        if !self.GRPC.is_empty() {
            os.write_string(13, &self.GRPC)?;
        }
        if self.GRPCUseTLS != false {
            os.write_bool(14, self.GRPCUseTLS)?;
        }
        if !self.AliasNode.is_empty() {
            os.write_string(15, &self.AliasNode)?;
        }
        if !self.AliasService.is_empty() {
            os.write_string(16, &self.AliasService)?;
        }
        if let Some(v) = self.TTL.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> HealthCheckDefinition {
        HealthCheckDefinition::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static HealthCheckDefinition {
        static instance: ::protobuf::rt::LazyV2<HealthCheckDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheckDefinition::new)
    }
}

impl ::protobuf::Clear for HealthCheckDefinition {
    fn clear(&mut self) {
        self.HTTP.clear();
        self.TLSSkipVerify = false;
        self.Header.clear();
        self.Method.clear();
        self.Body.clear();
        self.TCP.clear();
        self.Interval.clear();
        self.OutputMaxSize = 0;
        self.Timeout.clear();
        self.DeregisterCriticalServiceAfter.clear();
        self.ScriptArgs.clear();
        self.DockerContainerID.clear();
        self.Shell.clear();
        self.GRPC.clear();
        self.GRPCUseTLS = false;
        self.AliasNode.clear();
        self.AliasService.clear();
        self.TTL.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheckDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckDefinition {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct CheckType {
    // message fields
    pub CheckID: ::std::string::String,
    pub Name: ::std::string::String,
    pub Status: ::std::string::String,
    pub Notes: ::std::string::String,
    pub ScriptArgs: ::std::vec::Vec<::std::string::String>,
    pub HTTP: ::std::string::String,
    #[serde(default)]
    pub Header: ::std::collections::HashMap<::std::string::String, HeaderValue>,
    pub Method: ::std::string::String,
    pub Body: ::std::string::String,
    pub TCP: ::std::string::String,
    pub Interval: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub AliasNode: ::std::string::String,
    pub AliasService: ::std::string::String,
    pub DockerContainerID: ::std::string::String,
    pub Shell: ::std::string::String,
    pub GRPC: ::std::string::String,
    pub GRPCUseTLS: bool,
    pub TLSSkipVerify: bool,
    pub Timeout: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub TTL: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub SuccessBeforePassing: i32,
    pub FailuresBeforeCritical: i32,
    pub ProxyHTTP: ::std::string::String,
    pub ProxyGRPC: ::std::string::String,
    pub DeregisterCriticalServiceAfter: ::protobuf::MessageField<::protobuf::well_known_types::Duration>,
    pub OutputMaxSize: i32,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckType {
    fn default() -> &'a CheckType {
        <CheckType as ::protobuf::Message>::default_instance()
    }
}

impl CheckType {
    pub fn new() -> CheckType {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CheckID",
            |m: &CheckType| { &m.CheckID },
            |m: &mut CheckType| { &mut m.CheckID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Name",
            |m: &CheckType| { &m.Name },
            |m: &mut CheckType| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Status",
            |m: &CheckType| { &m.Status },
            |m: &mut CheckType| { &mut m.Status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Notes",
            |m: &CheckType| { &m.Notes },
            |m: &mut CheckType| { &mut m.Notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ScriptArgs",
            |m: &CheckType| { &m.ScriptArgs },
            |m: &mut CheckType| { &mut m.ScriptArgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HTTP",
            |m: &CheckType| { &m.HTTP },
            |m: &mut CheckType| { &mut m.HTTP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "Header",
            |m: &CheckType| { &m.Header },
            |m: &mut CheckType| { &mut m.Header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Method",
            |m: &CheckType| { &m.Method },
            |m: &mut CheckType| { &mut m.Method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Body",
            |m: &CheckType| { &m.Body },
            |m: &mut CheckType| { &mut m.Body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TCP",
            |m: &CheckType| { &m.TCP },
            |m: &mut CheckType| { &mut m.TCP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "Interval",
            |m: &CheckType| { &m.Interval },
            |m: &mut CheckType| { &mut m.Interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AliasNode",
            |m: &CheckType| { &m.AliasNode },
            |m: &mut CheckType| { &mut m.AliasNode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AliasService",
            |m: &CheckType| { &m.AliasService },
            |m: &mut CheckType| { &mut m.AliasService },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DockerContainerID",
            |m: &CheckType| { &m.DockerContainerID },
            |m: &mut CheckType| { &mut m.DockerContainerID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Shell",
            |m: &CheckType| { &m.Shell },
            |m: &mut CheckType| { &mut m.Shell },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GRPC",
            |m: &CheckType| { &m.GRPC },
            |m: &mut CheckType| { &mut m.GRPC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GRPCUseTLS",
            |m: &CheckType| { &m.GRPCUseTLS },
            |m: &mut CheckType| { &mut m.GRPCUseTLS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TLSSkipVerify",
            |m: &CheckType| { &m.TLSSkipVerify },
            |m: &mut CheckType| { &mut m.TLSSkipVerify },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "Timeout",
            |m: &CheckType| { &m.Timeout },
            |m: &mut CheckType| { &mut m.Timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "TTL",
            |m: &CheckType| { &m.TTL },
            |m: &mut CheckType| { &mut m.TTL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SuccessBeforePassing",
            |m: &CheckType| { &m.SuccessBeforePassing },
            |m: &mut CheckType| { &mut m.SuccessBeforePassing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FailuresBeforeCritical",
            |m: &CheckType| { &m.FailuresBeforeCritical },
            |m: &mut CheckType| { &mut m.FailuresBeforeCritical },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ProxyHTTP",
            |m: &CheckType| { &m.ProxyHTTP },
            |m: &mut CheckType| { &mut m.ProxyHTTP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ProxyGRPC",
            |m: &CheckType| { &m.ProxyGRPC },
            |m: &mut CheckType| { &mut m.ProxyGRPC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::Duration>(
            "DeregisterCriticalServiceAfter",
            |m: &CheckType| { &m.DeregisterCriticalServiceAfter },
            |m: &mut CheckType| { &mut m.DeregisterCriticalServiceAfter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OutputMaxSize",
            |m: &CheckType| { &m.OutputMaxSize },
            |m: &mut CheckType| { &mut m.OutputMaxSize },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CheckType>(
            "CheckType",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for CheckType {
    fn is_initialized(&self) -> bool {
        for v in &self.Interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TTL {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DeregisterCriticalServiceAfter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.CheckID = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Name = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Status = is.read_string()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Notes = is.read_string()?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ScriptArgs)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.HTTP = is.read_string()?;
                },
                20 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<HeaderValue>>(wire_type, is, &mut self.Header)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Method = is.read_string()?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Body = is.read_string()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TCP = is.read_string()?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Interval)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.AliasNode = is.read_string()?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.AliasService = is.read_string()?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DockerContainerID = is.read_string()?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Shell = is.read_string()?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.GRPC = is.read_string()?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.GRPCUseTLS = is.read_bool()?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TLSSkipVerify = is.read_bool()?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.Timeout)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.TTL)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SuccessBeforePassing = is.read_int32()?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.FailuresBeforeCritical = is.read_int32()?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ProxyHTTP = is.read_string()?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ProxyGRPC = is.read_string()?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.DeregisterCriticalServiceAfter)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.OutputMaxSize = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.CheckID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.CheckID);
        }
        if !self.Name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Name);
        }
        if !self.Status.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Status);
        }
        if !self.Notes.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Notes);
        }
        for value in &self.ScriptArgs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.HTTP.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.HTTP);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<HeaderValue>>(20, &self.Header);
        if !self.Method.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.Method);
        }
        if !self.Body.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.Body);
        }
        if !self.TCP.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.TCP);
        }
        if let Some(v) = self.Interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.AliasNode.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.AliasNode);
        }
        if !self.AliasService.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.AliasService);
        }
        if !self.DockerContainerID.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.DockerContainerID);
        }
        if !self.Shell.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.Shell);
        }
        if !self.GRPC.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.GRPC);
        }
        if self.GRPCUseTLS != false {
            my_size += 2;
        }
        if self.TLSSkipVerify != false {
            my_size += 3;
        }
        if let Some(v) = self.Timeout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.TTL.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.SuccessBeforePassing != 0 {
            my_size += ::protobuf::rt::value_size(21, self.SuccessBeforePassing, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FailuresBeforeCritical != 0 {
            my_size += ::protobuf::rt::value_size(22, self.FailuresBeforeCritical, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ProxyHTTP.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.ProxyHTTP);
        }
        if !self.ProxyGRPC.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.ProxyGRPC);
        }
        if let Some(v) = self.DeregisterCriticalServiceAfter.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.OutputMaxSize != 0 {
            my_size += ::protobuf::rt::value_size(25, self.OutputMaxSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.CheckID.is_empty() {
            os.write_string(1, &self.CheckID)?;
        }
        if !self.Name.is_empty() {
            os.write_string(2, &self.Name)?;
        }
        if !self.Status.is_empty() {
            os.write_string(3, &self.Status)?;
        }
        if !self.Notes.is_empty() {
            os.write_string(4, &self.Notes)?;
        }
        for v in &self.ScriptArgs {
            os.write_string(5, &v)?;
        };
        if !self.HTTP.is_empty() {
            os.write_string(6, &self.HTTP)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<HeaderValue>>(20, &self.Header, os)?;
        if !self.Method.is_empty() {
            os.write_string(7, &self.Method)?;
        }
        if !self.Body.is_empty() {
            os.write_string(26, &self.Body)?;
        }
        if !self.TCP.is_empty() {
            os.write_string(8, &self.TCP)?;
        }
        if let Some(v) = self.Interval.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.AliasNode.is_empty() {
            os.write_string(10, &self.AliasNode)?;
        }
        if !self.AliasService.is_empty() {
            os.write_string(11, &self.AliasService)?;
        }
        if !self.DockerContainerID.is_empty() {
            os.write_string(12, &self.DockerContainerID)?;
        }
        if !self.Shell.is_empty() {
            os.write_string(13, &self.Shell)?;
        }
        if !self.GRPC.is_empty() {
            os.write_string(14, &self.GRPC)?;
        }
        if self.GRPCUseTLS != false {
            os.write_bool(15, self.GRPCUseTLS)?;
        }
        if self.TLSSkipVerify != false {
            os.write_bool(16, self.TLSSkipVerify)?;
        }
        if let Some(v) = self.Timeout.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.TTL.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if self.SuccessBeforePassing != 0 {
            os.write_int32(21, self.SuccessBeforePassing)?;
        }
        if self.FailuresBeforeCritical != 0 {
            os.write_int32(22, self.FailuresBeforeCritical)?;
        }
        if !self.ProxyHTTP.is_empty() {
            os.write_string(23, &self.ProxyHTTP)?;
        }
        if !self.ProxyGRPC.is_empty() {
            os.write_string(24, &self.ProxyGRPC)?;
        }
        if let Some(v) = self.DeregisterCriticalServiceAfter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if self.OutputMaxSize != 0 {
            os.write_int32(25, self.OutputMaxSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> CheckType {
        CheckType::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static CheckType {
        static instance: ::protobuf::rt::LazyV2<CheckType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckType::new)
    }
}

impl ::protobuf::Clear for CheckType {
    fn clear(&mut self) {
        self.CheckID.clear();
        self.Name.clear();
        self.Status.clear();
        self.Notes.clear();
        self.ScriptArgs.clear();
        self.HTTP.clear();
        self.Header.clear();
        self.Method.clear();
        self.Body.clear();
        self.TCP.clear();
        self.Interval.clear();
        self.AliasNode.clear();
        self.AliasService.clear();
        self.DockerContainerID.clear();
        self.Shell.clear();
        self.GRPC.clear();
        self.GRPCUseTLS = false;
        self.TLSSkipVerify = false;
        self.Timeout.clear();
        self.TTL.clear();
        self.SuccessBeforePassing = 0;
        self.FailuresBeforeCritical = 0;
        self.ProxyHTTP.clear();
        self.ProxyGRPC.clear();
        self.DeregisterCriticalServiceAfter.clear();
        self.OutputMaxSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckType {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!proto/pbservice/healthcheck.proto\x12\tpbservice\x1a\x1egoogle/protob\
    uf/duration.proto\x1a\x1bproto/pbcommon/common.proto\x1a\x14gogoproto/go\
    go.proto\"\x83\x04\n\x0bHealthCheck\x12\x12\n\x04Node\x18\x01\x20\x01(\t\
    R\x04Node\x12G\n\x07CheckID\x18\x02\x20\x01(\tR\x07CheckIDB-\xfa\xde\x1f\
    )github.com/hashicorp/consul/types.CheckID\x12\x12\n\x04Name\x18\x03\x20\
    \x01(\tR\x04Name\x12\x16\n\x06Status\x18\x04\x20\x01(\tR\x06Status\x12\
    \x14\n\x05Notes\x18\x05\x20\x01(\tR\x05Notes\x12\x16\n\x06Output\x18\x06\
    \x20\x01(\tR\x06Output\x12\x1c\n\tServiceID\x18\x07\x20\x01(\tR\tService\
    ID\x12\x20\n\x0bServiceName\x18\x08\x20\x01(\tR\x0bServiceName\x12\x20\n\
    \x0bServiceTags\x18\t\x20\x03(\tR\x0bServiceTags\x12\x12\n\x04Type\x18\
    \x0c\x20\x01(\tR\x04Type\x12F\n\nDefinition\x18\n\x20\x01(\x0b2\x20.pbse\
    rvice.HealthCheckDefinitionR\nDefinitionB\x04\xc8\xde\x1f\0\x129\n\tRaft\
    Index\x18\x0b\x20\x01(\x0b2\x11.common.RaftIndexR\tRaftIndexB\x08\xc8\
    \xde\x1f\0\xd0\xde\x1f\x01\x12D\n\x0eEnterpriseMeta\x18\r\x20\x01(\x0b2\
    \x16.common.EnterpriseMetaR\x0eEnterpriseMetaB\x04\xc8\xde\x1f\0\"#\n\
    \x0bHeaderValue\x12\x14\n\x05Value\x18\x01\x20\x03(\tR\x05Value\"\xd2\
    \x06\n\x15HealthCheckDefinition\x12\x12\n\x04HTTP\x18\x01\x20\x01(\tR\
    \x04HTTP\x12$\n\rTLSSkipVerify\x18\x02\x20\x01(\x08R\rTLSSkipVerify\x12J\
    \n\x06Header\x18\x03\x20\x03(\x0b2,.pbservice.HealthCheckDefinition.Head\
    erEntryR\x06HeaderB\x04\xc8\xde\x1f\0\x12\x16\n\x06Method\x18\x04\x20\
    \x01(\tR\x06Method\x12\x12\n\x04Body\x18\x12\x20\x01(\tR\x04Body\x12\x10\
    \n\x03TCP\x18\x05\x20\x01(\tR\x03TCP\x12?\n\x08Interval\x18\x06\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x08IntervalB\x08\x98\xdf\x1f\x01\xc8\
    \xde\x1f\0\x12$\n\rOutputMaxSize\x18\t\x20\x01(\rR\rOutputMaxSize\x12=\n\
    \x07Timeout\x18\x07\x20\x01(\x0b2\x19.google.protobuf.DurationR\x07Timeo\
    utB\x08\x98\xdf\x1f\x01\xc8\xde\x1f\0\x12k\n\x1eDeregisterCriticalServic\
    eAfter\x18\x08\x20\x01(\x0b2\x19.google.protobuf.DurationR\x1eDeregister\
    CriticalServiceAfterB\x08\x98\xdf\x1f\x01\xc8\xde\x1f\0\x12\x1e\n\nScrip\
    tArgs\x18\n\x20\x03(\tR\nScriptArgs\x12,\n\x11DockerContainerID\x18\x0b\
    \x20\x01(\tR\x11DockerContainerID\x12\x14\n\x05Shell\x18\x0c\x20\x01(\tR\
    \x05Shell\x12\x12\n\x04GRPC\x18\r\x20\x01(\tR\x04GRPC\x12\x1e\n\nGRPCUse\
    TLS\x18\x0e\x20\x01(\x08R\nGRPCUseTLS\x12\x1c\n\tAliasNode\x18\x0f\x20\
    \x01(\tR\tAliasNode\x12\"\n\x0cAliasService\x18\x10\x20\x01(\tR\x0cAlias\
    Service\x125\n\x03TTL\x18\x11\x20\x01(\x0b2\x19.google.protobuf.Duration\
    R\x03TTLB\x08\x98\xdf\x1f\x01\xc8\xde\x1f\0\x1aQ\n\x0bHeaderEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12,\n\x05value\x18\x02\x20\x01\
    (\x0b2\x16.pbservice.HeaderValueR\x05value:\x028\x01\"\xed\x08\n\tCheckT\
    ype\x12G\n\x07CheckID\x18\x01\x20\x01(\tR\x07CheckIDB-\xfa\xde\x1f)githu\
    b.com/hashicorp/consul/types.CheckID\x12\x12\n\x04Name\x18\x02\x20\x01(\
    \tR\x04Name\x12\x16\n\x06Status\x18\x03\x20\x01(\tR\x06Status\x12\x14\n\
    \x05Notes\x18\x04\x20\x01(\tR\x05Notes\x12\x1e\n\nScriptArgs\x18\x05\x20\
    \x03(\tR\nScriptArgs\x12\x12\n\x04HTTP\x18\x06\x20\x01(\tR\x04HTTP\x12>\
    \n\x06Header\x18\x14\x20\x03(\x0b2\x20.pbservice.CheckType.HeaderEntryR\
    \x06HeaderB\x04\xc8\xde\x1f\0\x12\x16\n\x06Method\x18\x07\x20\x01(\tR\
    \x06Method\x12\x12\n\x04Body\x18\x1a\x20\x01(\tR\x04Body\x12\x10\n\x03TC\
    P\x18\x08\x20\x01(\tR\x03TCP\x12?\n\x08Interval\x18\t\x20\x01(\x0b2\x19.\
    google.protobuf.DurationR\x08IntervalB\x08\x98\xdf\x1f\x01\xc8\xde\x1f\0\
    \x12\x1c\n\tAliasNode\x18\n\x20\x01(\tR\tAliasNode\x12\"\n\x0cAliasServi\
    ce\x18\x0b\x20\x01(\tR\x0cAliasService\x12,\n\x11DockerContainerID\x18\
    \x0c\x20\x01(\tR\x11DockerContainerID\x12\x14\n\x05Shell\x18\r\x20\x01(\
    \tR\x05Shell\x12\x12\n\x04GRPC\x18\x0e\x20\x01(\tR\x04GRPC\x12\x1e\n\nGR\
    PCUseTLS\x18\x0f\x20\x01(\x08R\nGRPCUseTLS\x12$\n\rTLSSkipVerify\x18\x10\
    \x20\x01(\x08R\rTLSSkipVerify\x12=\n\x07Timeout\x18\x11\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x07TimeoutB\x08\x98\xdf\x1f\x01\xc8\xde\
    \x1f\0\x125\n\x03TTL\x18\x12\x20\x01(\x0b2\x19.google.protobuf.DurationR\
    \x03TTLB\x08\x98\xdf\x1f\x01\xc8\xde\x1f\0\x122\n\x14SuccessBeforePassin\
    g\x18\x15\x20\x01(\x05R\x14SuccessBeforePassing\x126\n\x16FailuresBefore\
    Critical\x18\x16\x20\x01(\x05R\x16FailuresBeforeCritical\x12\x1c\n\tProx\
    yHTTP\x18\x17\x20\x01(\tR\tProxyHTTP\x12\x1c\n\tProxyGRPC\x18\x18\x20\
    \x01(\tR\tProxyGRPC\x12k\n\x1eDeregisterCriticalServiceAfter\x18\x13\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x1eDeregisterCriticalServiceAft\
    erB\x08\xc8\xde\x1f\0\x98\xdf\x1f\x01\x12$\n\rOutputMaxSize\x18\x19\x20\
    \x01(\x05R\rOutputMaxSize\x1aQ\n\x0bHeaderEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12,\n\x05value\x18\x02\x20\x01(\x0b2\x16.pbservice.\
    HeaderValueR\x05value:\x028\x01B=Z+github.com/hashicorp/consul/proto/pbs\
    ervice\xd8\xe3\x1e\0\xd0\xe3\x1e\0\x90\xe3\x1e\0\xc8\xe1\x1e\0b\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(::protobuf::well_known_types::file_descriptors::duration());
        deps.push(super::common::file_descriptor());
        deps.push(super::gogo::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(HealthCheck::generated_message_descriptor_data());
        messages.push(HeaderValue::generated_message_descriptor_data());
        messages.push(HealthCheckDefinition::generated_message_descriptor_data());
        messages.push(CheckType::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
